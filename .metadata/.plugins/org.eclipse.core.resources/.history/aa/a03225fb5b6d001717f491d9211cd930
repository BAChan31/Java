import java.util.*;

//인접행렬과 해쉬 테이블 사용한 BFS
public class BFSTest {
	
	static int Ne; //간선의 수
	static int Nv; //정점의 수
	static int[][] adjacencyMatrix;
	static boolean[] visit;
	static Queue<Integer> queue;
	
	public static void bfs(int i) {
		queue = new <Integer> LinkedList();
		HashMap <Integer, Boolean> hash = new HashMap<Integer, Boolean>();
		
		queue.offer(i);
		
		while(!queue.isEmpty()){
			int temp = queue.poll();
			visit[temp] = true;
			System.out.print(temp);
			
			for(int j=1; j <= Ne; j++){
				if(adjacencyMatrix[temp][j] == 1 && visit[j] == false)
				{
					if(!hash.containsKey(j))
					{
						queue.offer(j);
						hash.put(j,true);
					}
				}
			}
		}
	}
	
	public static void main(String[] args)
	{
		Scanner scan = new Scanner(System.in);
		Ne = scan.nextInt();
		Nv = scan.nextInt();
		
		adjacencyMatrix = new int[Nv+1][Nv+1];
		visit = new boolean[Nv+1];
		
		for(int i = 0; i < Nv; i++)
		{
			int t1, t2;
			t1 = scan.nextInt();
			t2 = scan.nextInt();
			
			adjacencyMatrix[t1][t2] = adjacencyMatrix[t2][t1] = 1;
		}
		
		bfs(1);
	}
}
